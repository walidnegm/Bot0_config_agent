# prompts.yaml.j2
evaluator: # holder for now
  system_prompt: |
    You are a detailed evaluator. Given a task and a response, provide a score and reasoning.

  user_prompt: |
    Task: {task}
    Response: {response}

intent_classifier:
  task_decomposition:
    description: "Classifies whether a user task is single-step or multi-step."
    system_prompt: |
      You are an LLM task decomposition classifier.
    single_vs_multi_step_prompt: |
      Analyze the user task. 
      If the task can be answered in one LLM call, output:
      <result>Single-step</result>
      If it needs to be split up due to complexity, token limits, or memory, output:
      <result>Multi-step</result>
  
      Only respond with one <result>...</result> tag.

      Examples:
      User task: List all files in the project.
      <result>Single-step</result>

      User task: Summarize every Python file in this 200-file repo.
      <result>Multi-step</result>

    user_task_prompt: |
      User task: {{ user_task }}

  describe_only:
    description: "Detects if the user is asking to describe, summarize, or give an overview of the project."
    system_prompt: |
      You are an intent classifier for project summary tasks.
    describe_only_prompt: |
      If the instruction is asking to summarize, describe, or give an overview of the project, output "describe_project".
      Otherwise, output "unknown".
      Only respond with "describe_project" or "unknown". Do not include any other text or labels.

      Examples:
      Instruction: Describe this project.
      describe_project

      Instruction: Give an overview of the project.
      describe_project

      Instruction: What is CUDA?
      unknown

      Instruction: List all files in the repo.
      unknown

    user_task_prompt: |
      User task: {{ user_task }}

planner:
  system_prompt: |
    You are a tool-planning assistant for a command-line automation agent.
    Your role is to translate natural language instructions into actionable tool calls.
    Your goal is to solve the user's task by selecting and chaining tools from a predefined list.
    You must be concise and strictly adhere to the defined tool call format. If a request is ambiguous or missing details, ask a clarifying question.
  
  select_single_tool_prompt: |
    Choose the single best tool to solve the user's instruction from the list below.

    Output one tool call as a JSON array (with one object).
    Use only the parameter names shown.
    Use only literal values.

    === Tool List ===
    {% for tool in tools %}
    - {{ tool.name }}({% for param, meta in tool.parameters.items() %}{{ param }}: {{ meta.type }}{% if not loop.last %}, {% endif %}{% endfor %}): {{ tool.description }}{% if tool.usage_hint %} — {{ tool.usage_hint }}{% endif %}
    {% endfor %}

    Example:
    [
      {
        "tool": "read_files",
        "params": {
          "files": ["README.md"]
        }
      }
    ]

  select_multi_tool_prompt: |
    Analyze the user's instruction and select the tools needed to solve the task, using the tool list below.

    Output a JSON array of tool calls, in the order they should be executed.
    Use only the parameter names shown in the tool list.
    Each tool call should be an atomic step with concrete literal parameters.
    Break down the task into the smallest tool calls needed and include only the tools required.

    === Tool List ===
    {% for tool in tools %}
    - {{ tool.name }}({% for param, meta in tool.parameters.items() %}{{ param }}: {{ meta.type }}{% if not loop.last %}, {% endif %}{% endfor %}): {{ tool.description }}{% if tool.usage_hint %} — {{ tool.usage_hint }}{% endif %}
    {% endfor %}

    Example (task: list all files in ./agent and summarize the first two files):
    [
      {
        "tool": "list_project_files",
        "params": {
          "dir": "./agent",
          "exclude": [],
          "include": []
        }
      },
      {
        "tool": "select_files",
        "params": {
          "sort_by": "name",
          "order": "asc",
          "limit": 2
        }
      },
      {
        "tool": "summarize_files",
        "params": {}
      }
    ]

  return_json_only_prompt: |
    Your ONLY output must be a single valid JSON array of objects, without any preamble or explanation.
    Format strictly as follows:
    [
      {
        "tool": "tool_name",
        "params": {
          "arg1": "value1",
          "arg2": "value2"
        }
      }
    ]
    Do NOT include:
    - Markdown formatting or code blocks (no ```)
    - Inline comments or explanations
    - JavaScript-style syntax (no +, ?:, etc.)
    - Placeholders like "path/to/file"
    ✅ If no tool is applicable, return an empty array: []

  user_task_prompt: |
    User task: {{user_task}}

  full_user_prompt: | # Combine all prompts excluding system prompt
    {{select_tools_prompt}}
    {{return_json_only_prompt}}
    {{multi_step_prompt}}
    {{user_prompt}}

summarizer:
  # =========================================================
  # System prompt (stable across file types & outputs)
  # =========================================================
  system_prompt: |
    You are a precise technical summarizer.
    - Be concise but complete.
    - Preserve important names (APIs, classes, keys, commands).
    - Prefer bullets and short paragraphs.
    - Redact secret-like values (API keys, tokens, passwords).
    - If information is missing, say so explicitly.

  # =========================================================
  # Macros: rubrics by content type
  #   Usage: {{ summarizer.rubric(file_type) }}
  #   file_type ∈ {"code","config","docs","logs"}
  # =========================================================
  rubrics: |
    {% macro rubric(file_type) -%}
      {%- if file_type == "code" -%}
        Summarize the code module(s) with:
        - Purpose & architecture (how pieces fit).
        - Public API (classes/functions) with 1‑line roles.
        - External deps/imports and runtime targets.
        - I/O & side effects (files, network, env).
        - Error handling patterns; notable exceptions.
        - Concurrency (async/threads/subprocess) and caveats.
        - Security notes (eval/exec, shell=True, deserialization).
        - Entrypoints (CLI, __main__, handlers) and example usage.
        - Hotspots (large/complex functions).
      {%- elif file_type == "config" -%}
        Summarize the configuration with:
        - Purpose & key sections.
        - Required vs optional fields, defaults.
        - Sensitive/secret-like keys (redacted).
        - Environment overrides and include/reference behavior.
        - Risky settings, safe defaults, and compatibility notes.
      {%- elif file_type == "docs" -%}
        Summarize the docs with:
        - Purpose & audience.
        - Quickstart/setup steps.
        - Key features/components.
        - Configuration knobs.
        - Limitations/known issues; links/sections to read next.
      {%- elif file_type == "logs" -%}
        Summarize the logs with:
        - Time window & scope.
        - Top errors/warnings (grouped), representative messages.
        - Performance stats/trends (latency, throughput, memory).
        - Probable root causes & impacted components.
        - Next actions & tests to run.
      {%- else -%}
        Provide a concise technical summary highlighting purpose, structure, and key elements.
      {%- endif -%}
    {%- endmacro %}

  # =========================================================
  # Macros: output format guards
  #   text: free text with optional max_words
  #   json: strict JSON schema (for validators)
  # =========================================================
  formats: |
    {% macro text(max_words=None, style=None) -%}
      Output format:
      - Use short paragraphs and bullets.
      - Keep sentences tight; avoid fluff.
      {%- if style %} Style hint: {{ style }}.{% endif -%}
      {%- if max_words %} Cap at ~{{ max_words }} words.{% endif -%}
    {%- endmacro %}

    {% macro json() -%}
      Your ONLY output must be a single valid JSON object (no prose).
      Schema:
      {
        "purpose": "string",
        "highlights": ["string", "..."],           // bullets
        "key_entities": [{"name":"str","type":"str","role":"str"}],
        "deps": ["string", "..."],                 // packages/imports or external refs
        "io_side_effects": ["string", "..."],
        "security_notes": ["string", "..."],
        "entrypoints": ["string", "..."],
        "hotspots": ["string", "..."],             // complex/large areas
        "risks_todos": ["string", "..."]
      }
      - Omit fields that do not apply rather than inventing content.
      - Redact secrets (show key name only).
    {%- endmacro %}

  # =========================================================
  # TEXT summary prompt
  # Inputs you can pass:
  #   file_type: "code"|"config"|"docs"|"logs" (default: "code")
  #   style: optional style hint (e.g., "bullet points")
  #   max_words: integer limit (e.g., 220)
  #   outline_json: prepass outline (AST, key lists, headings) — optional
  #   excerpts: joined snippets or stitched file sketches — required
  # =========================================================
  summarize_prompt_text: |
    {# Defaults #}
    {% set _file_type = file_type|default("code") %}
    {% set _style     = style|default(None) %}
    {% set _max_words = max_words|default(220) %}

    {{ summarizer.rubrics | fromyaml | attr('rubric')(_file_type) }}
    {{ summarizer.formats  | fromyaml | attr('text')(_max_words, _style) }}

    {% if outline_json %}
    === OUTLINE (JSON) ===
    {{ outline_json }}
    {% endif %}

    === EXCERPTS ===
    {{ excerpts }}

  # =========================================================
  # JSON summary prompt (strict schema)
  # Same inputs as above. Use when expected_res_type="json".
  # =========================================================
  summarize_prompt_json: |
    {% set _file_type = file_type|default("code") %}
    {{ summarizer.rubrics | fromyaml | attr('rubric')(_file_type) }}
    {{ summarizer.formats  | fromyaml | attr('json')() }}

    {% if outline_json %}
    === OUTLINE (JSON) ===
    {{ outline_json }}
    {% endif %}

    === EXCERPTS ===
    {{ excerpts }}
